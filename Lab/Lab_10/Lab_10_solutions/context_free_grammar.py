#  Written by Eric Martin for COMP9021


import re
from functools import partial

from binary_tree_adt import BinaryTree


'''
Builds a parse tree for an expression generated by the grammar:
                 EXPRESSION --> EXPRESSION TERM_OPERATOR TERM
                 EXPRESSION --> TERM
                 TERM --> TERM FACTOR_OPERATOR FACTOR
                 TERM --> FACTOR
                 FACTOR --> NUMBER
                 FACTOR --> (EXPRESSION)
                 NUMBER --> DIGIT NUMBER | DIGIT
                 DIGIT --> 0 | ... | 9
                 TERM_OPERATOR --> + | -
                 FACTOR_OPERATOR --> * | /
with all operators associating to the left.
'''


def parse_tree(expression):
    '''
    Checks whether an expression can be generated by the grammar,
    and in case the answer is yes, returns a parse tree for the expression.
    Note that all operators associate to the left.

    >>> parse_tree('100').print_binary_tree()
    100
    >>> parse_tree('1 - 20 + 300').print_binary_tree()
                1
          -
                20
    +
    <BLANKLINE>
          300
    <BLANKLINE>
    >>> parse_tree('1 - (20 + 300)').print_binary_tree()
    <BLANKLINE>
          1
    <BLANKLINE>
    -
                20
          +
                300
    >>> parse_tree('20 * 4 / 5').print_binary_tree()
                20
          *
                4
    /
    <BLANKLINE>
          5
    <BLANKLINE>
    >>> parse_tree('20 * (4 / 5)').print_binary_tree()
    <BLANKLINE>
          20
    <BLANKLINE>
    *
                4
          /
                5
    >>> parse_tree('1 + 20 * (30 - 400)').print_binary_tree()
    <BLANKLINE>
    <BLANKLINE>
    <BLANKLINE>
          1
    <BLANKLINE>
    <BLANKLINE>
    <BLANKLINE>
    +
    <BLANKLINE>
                20
    <BLANKLINE>
          *
                      30
                -
                      400
    >>> parse_tree('(1 + 20) * (30 - 400)').print_binary_tree()
                1
          +
                20
    *
                30
          -
                400
    '''
    if any(not (c.isdigit() or c.isspace() or c in '()+-*/') for c in expression):
        return
    # Tokens can be natural numbers, (, ), +, -, *, and /
    tokens = re.compile('(\d+|\(|\)|\+|-|\*|/)').findall(expression)
    tokens.reverse()
    parse_tree = parse_tree_for_expression_or_term('+-', tokens)
    if len(tokens):
        return
    return parse_tree
    

def parse_tree_for_expression_or_term(operators, tokens):
    parse_tree_function = (partial(parse_tree_for_expression_or_term, '*/')  if '+' in operators
                                                                          else parse_tree_for_factor
                          )
    tree = parse_tree_function(tokens)
    if tree is None:
        return
    parse_tree = None
    while len(tokens) and tokens[-1] in operators:
        operator = tokens.pop()
        other_tree = parse_tree_function(tokens)
        if other_tree is None:
            return
        parse_tree = BinaryTree(operator)
        parse_tree.left_node = tree
        parse_tree.right_node = other_tree
        tree = parse_tree
    if not parse_tree:
        return tree
    return parse_tree


def parse_tree_for_factor(tokens):
    try:
        token = tokens.pop()
        return BinaryTree(int(token))
    # No token was left
    except IndexError:
        return
    except ValueError:
        if token != '(':
            return
        parse_tree = parse_tree_for_expression_or_term('+-', tokens)
        if len(tokens) and tokens.pop() == ')':
            return parse_tree
        return


if __name__ == '__main__':
    import doctest
    doctest.testmod()
